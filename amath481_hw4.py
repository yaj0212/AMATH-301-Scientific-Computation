# -*- coding: utf-8 -*-
"""AMATH481-HW4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B8DVVfRzvg0Dzslx8Hiar-wAUkgThWPH
"""

import numpy as np
import matplotlib.pyplot as plt

# u_t = -c * u_xx
# u(0, x) = u0(x)
# u(t, -1) = u(t, 1) = 0
# u(t, x) = true_solution

c = -5

def u0(x):
    return np.sin((4 * np.pi / 3) * (x + 1))

def true_solution(t, x):
    return np.sin(4 * np.pi * (x + 1) / 3) * np.exp(-5 * 16 * (np.pi ** 2) * t / 9)

x0 = -1
xf = 2
Nx = 25
x = np.linspace(x0, xf, Nx)
dx = x[1] - x[0]

A = np.diag(-2 * np.ones(Nx - 2)) + np.diag(np.ones(Nx - 3), 1) + np.diag(np.ones(Nx - 3), -1)
A = (-c / (dx ** 2)) * A
# print(A.shape)
# print("A = {}".format(A))

#  1a
t0 = 0
tf = 0.25
Nt = 257
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = 0

# Forward Euler
for k in range(Nt - 1):
    U[1:Nx-1, (k + 1):(k + 2)] = U[1:Nx-1, k:(k + 1)] + dt * A @ U[1:Nx-1, k:(k + 1)]
# print("U = {}".format(U))

index_t1 = len(t) - 1
index_x1 = int((0 - (-1))/0.125)
A1 = U[index_x1, index_t1]
print("A1 = {}".format(A1))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A2 = np.max(np.abs(U_true - U))
print("A2 = {}".format(A2))


#1b
Nt = 139
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]


U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = 0

# Forward Euler
for k in range(Nt - 1):
    U[1:-1, (k + 1):(k + 2)] = U[1:-1, k:(k + 1)] + dt * A @ U[1:-1, k:(k + 1)]
# print("U = {}".format(U))

index_t1 = len(t) - 1
index_x1 = int((0 - (-1))/0.125)
A3 = U[index_x1, index_t1]
print("A3 = {}".format(A3))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A4 = np.max(np.abs(U_true - U))
print("A4 = {}".format(A4))


#1c
Nt = 6
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]


U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = 0

# Backward Euler
A_backward = np.eye(Nx - 2) - dt * A
for k in range(Nt - 1):
    U[1:-1, (k + 1):(k + 2)] = np.linalg.solve(A_backward, U[1:-1, k:(k + 1)])
# print("U = {}".format(U))

index_t1 = len(t) - 1
index_x1 = int((0 - (-1))/0.125)
A5 = U[index_x1, index_t1]
print("A5 = {}".format(A5))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A6 = np.max(np.abs(U_true - U))
print("A6 = {}".format(A6))

#1d
Nt = 51
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = 0

# Backward Euler
A_backward = np.eye(Nx - 2) - dt * A
for k in range(Nt - 1):
    U[1:-1, (k + 1):(k + 2)] = np.linalg.solve(A_backward, U[1:-1, k:(k + 1)])
# print("U = {}".format(U))

index_t1 = len(t) - 1
index_x1 = int((0 - (-1))/0.125)
A7 = U[index_x1, -1]
print("A7 = {}".format(A7))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A8 = np.max(np.abs(U_true - U))
print("A8 = {}".format(A8))

import numpy as np
import matplotlib.pyplot as plt


# u_t = u_xx + 10x
# u(0, x) = sin(np.pi * x) - 0.8 * np.sin(3*np.pi*x)
# u(t, 0) = 0
# u(t, 1) = 10t
# u(t, x) = true_solution

def u0(x):
  return np.sin(np.pi * x) - 0.8 * np.sin(3 * np.pi * x)

def ut1(t):
  return 10 * t

def true_solution(t, x):
  return 10 * t * x + np.exp(-(np.pi**2 * t)) * np.sin(np.pi * x) - 0.8 * np.exp(- (9 * np.pi** 2 * t)) * np.sin(3 * np.pi * x)

x0 = 0
xf = 1
Nx = 21
x = np.linspace(x0, xf, Nx)
dx = x[1] - x[0]

def c(t):
  c = 10 * x[1:-1]
  c[-1] += 10 * t / dx**2
  return c

A = np.diag(-2 * np.ones(Nx - 2)) + np.diag(np.ones(Nx - 3), 1) + np.diag(np.ones(Nx - 3), -1)
A = A / (dx ** 2)
# print("A = {}".format(A))

t0 = 0
tf = 0.1

# 2a
Nt = 56
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = ut1(t)

# Forward Euler
for k in range(Nt - 1):
    U[1:-1, (k + 1)] = U[1:-1, k] + dt * (A @ U[1:-1, k] + c(t[k]))
index_t2 = Nt - 1
index_x2 = int(Nx / 2)
A9 = U[index_x2, index_t2]
print("A9 = {}".format(A9))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A10 = np.max(np.abs(U_true - U))
print("A10 = {}".format(A10))

# 2b
Nt = 201
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = ut1(t)

# Forward Euler
for k in range(Nt - 1):
    U[1:-1, (k + 1)] = U[1:-1, k] + dt * (A @ U[1:-1, k] + c(t[k]))
index_t2 = Nt - 1
index_x2 = int(Nx / 2)
A11 = U[index_x2, index_t2]
print("A11 = {}".format(A11))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A12 = np.max(np.abs(U_true - U))
print("A12 = {}".format(A12))

# 2c
Nt = 11
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = ut1(t)

# Trapezoidal
A_trap1 = np.eye(Nx - 2) - (dt/2) * A
A_trap2 = np.eye(Nx - 2) + (dt/2) * A
for k in range(Nt - 1):
    U[1:-1, (k + 1)] = np.linalg.solve(A_trap1, A_trap2 @ U[1:-1, k] + (dt/2) * (c(t[k]) + c(t[k + 1])))
index_t2 = Nt - 1
index_x2 = int(Nx / 2)
A13 = U[index_x2, index_t2]
print("A13 = {}".format(A13))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A14 = np.max(np.abs(U_true - U))
print("A14 = {}".format(A14))

# 2d
Nt = 101
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)
U[0, :] = 0
U[-1, :] = ut1(t)

# Trapezoidal
A_trap1 = np.eye(Nx - 2) - (dt/2) * A
A_trap2 = np.eye(Nx - 2) + (dt/2) * A
for k in range(Nt - 1):
    U[1:-1, (k + 1)] = np.linalg.solve(A_trap1, A_trap2 @ U[1:-1, k] + (dt/2) * (c(t[k]) + c(t[k + 1])))
index_t2 = Nt - 1
index_x2 = int(Nx / 2)
A15 = U[index_x2, index_t2]
print("A15 = {}".format(A15))

U_true = np.zeros((Nx, Nt))
for i in range(Nx):
    for j in range(Nt):
        U_true[i, j] = true_solution(t[j], x[i])
A16 = np.max(np.abs(U_true - U))
print("A16 = {}".format(A16))

import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import scipy as sp

# u_t = -c * (u_xx + u_yy)
# u(t, 0, 1) = u(t, 1, y) = 0
# u(t, x, 0) = u(t, x, 1) = 0
# u(0, x, y) = np.exp(-10*((x-0.5)**2+(y-0.5)**2)) for x > 0, y < 1
# u(0, x, y) = 0 for x = 0 y = 0 or x = 1 y = 1
# u(t, x, y) = true_solution

c = -0.1

def u(x,y):
  return np.exp(-10 * ((x - 0.5)**2 + (y - 0.5)**2))

x0 = 0
xf = 1
Nx = 11
x = np.linspace(x0, xf, Nx)
dx = x[1] - x[0]
y0 = 0
yf = 1
Ny = 11
y = np.linspace(y0, yf, Ny)
dy = y[1] - y[0]

x = np.linspace(x0, xf, Nx)
y = np.linspace(y0, yf, Ny)

t0 = 0
tf = 1

A = (np.diag(-2 * np.ones(Nx - 2)) + np.diag(np.ones(Nx - 3), 1)
      + np.diag(np.ones(Nx - 3), -1))
A = -c * A / dx ** 2

# 3a
Nt = 4
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Ny, Nt))
for j in range(1, Ny-1):
    for i in range(1, Nx-1):
        U[i, j, 0] = u(x[i], y[j])

def f_2d(U_slice):
    return np.array([A @ row for row in U_slice])

# Forward Euler
for k in range(len(t) - 1):
    U[1:-1, 1:-1, k + 1] = U[1:-1, 1:-1, k] + dt * (f_2d(U[1:-1, 1:-1, k])
                            + f_2d(U[1:-1, 1:-1, k].T).T)

index_x3 = int((0.5 - 0) / 0.1)
index_y3 = int((0.5 - 0) / 0.1)
index_t3 = Nt - 1
A17 = U[index_x3, index_y3, index_t3]
print("A17 = {}".format(A17))

X, Y = np.meshgrid(x, y)
time_indices = [0, 1 / 3, 2 / 3, 1]
fig, axes = plt.subplots(2, 2, figsize=(10, 8), subplot_kw={'projection': '3d'})
fig.suptitle('Surface Plot of Forward Euler Solution at dt = 1/3', fontsize=16)
for idx, ax in zip(time_indices, axes.flatten()):
    time_index = int(idx * (Nt - 1))
    surf = ax.plot_surface(X, Y, U[:, :, time_index], cmap='viridis', alpha=0.7)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('U')
    ax.set_title(f'Time = {t[time_index]:.2f}')
plt.show()

# 3b
Nt = 101
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Ny, Nt))
for j in range(1, Ny-1):
    for i in range(1, Nx-1):
        U[i, j, 0] = u(x[i], y[j])

def f_2d(U_slice):
    return np.array([A @ row for row in U_slice])

# Forward Euler
for k in range(len(t) - 1):
    U[1:-1, 1:-1, k + 1] = U[1:-1, 1:-1, k] + dt * (f_2d(U[1:-1, 1:-1, k])
                            + f_2d(U[1:-1, 1:-1, k].T).T)

index_x3 = int((0.5 - 0) / 0.1)
index_y3 = int((0.5 - 0) / 0.1)
index_t3 = Nt - 1
A18 = U[index_x3, index_y3, index_t3]
print("A18 = {}".format(A18))

X, Y = np.meshgrid(x, y)
time_indices = [0, 0.33, 0.67, 1]
fig, axes = plt.subplots(2, 2, figsize=(10, 8), subplot_kw={'projection': '3d'})
fig.suptitle('Surface Plots of Forward Euler Solution at dt = 0.01', fontsize=16)
for idx, ax in zip(time_indices, axes.flatten()):
    time_index = int(idx * (Nt - 1))
    surf = ax.plot_surface(X, Y, U[:, :, time_index], cmap='viridis', alpha=0.7)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('U')
    ax.set_title(f'Time = {t[time_index]:.2f}')
plt.show()

# 3c
Nt = 4
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Ny, Nt))
for j in range(1, Ny-1):
    for i in range(1, Nx-1):
        U[i, j, 0] = u(x[i], y[j])

# Trapezoidal
Ax = (np.diag(-2 * np.ones(Nx - 2)) + np.diag(np.ones(Nx - 3), k=1)
      + np.diag(np.ones(Nx - 3), k=-1)) / dx**2
Ay = (np.diag(-2 * np.ones(Ny - 2)) + np.diag(np.ones(Ny - 3), k=1)
      + np.diag(np.ones(Ny - 3), k=-1)) / dy**2

A_t = np.kron(np.eye(Ny - 2), Ax) + np.kron(Ay, np.eye(Nx - 2))

A_trap1 = np.eye((Nx - 2) * (Ny - 2))- (dt/2) * 0.1 * A_t
A_trap2 = np.eye((Nx - 2) * (Ny - 2)) + (dt/2) * 0.1 * A_t

for k in range(Nt - 1):
  U_ravel = U[1:-1, 1:-1, k].ravel()
  U_ravel = sp.linalg.solve(A_trap1, A_trap2.dot(U_ravel))
  U[1:-1, 1:-1, (k + 1)] = U_ravel.reshape((Nx - 2, Ny - 2))

index_x3 = int((0.5 - 0) / 0.1)
index_y3 = int((0.5 - 0) / 0.1)
index_t3 = Nt - 1
A19 = U[index_x3, index_y3, index_t3]
print("A19 = {}".format(A19))

X, Y = np.meshgrid(x, y)
time_indices = [0, 1 / 3, 2 / 3, 1]
fig, axes = plt.subplots(2, 2, figsize=(10, 8), subplot_kw={'projection': '3d'})
fig.suptitle('Surface Plots of Trapezoidal Solution at dt = 1/3', fontsize=16)
for idx, ax in zip(time_indices, axes.flatten()):
    time_index = int(idx * (Nt - 1))
    surf = ax.plot_surface(X, Y, U[:, :, time_index], cmap='viridis', alpha=0.7)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('U')
    ax.set_title(f'Time = {t[time_index]:.2f}')
plt.show()

# 3d
Nt = 101
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]

U = np.zeros((Nx, Ny, Nt))
for j in range(1, Ny-1):
    for i in range(1, Nx-1):
        U[i, j, 0] = u(x[i], y[j])

# Trapezoidal
Ax = (np.diag(-2 * np.ones(Nx - 2)) + np.diag(np.ones(Nx - 3), k=1)
      + np.diag(np.ones(Nx - 3), k=-1)) / dx**2
Ay = (np.diag(-2 * np.ones(Ny - 2)) + np.diag(np.ones(Ny - 3), k=1)
      + np.diag(np.ones(Ny - 3), k=-1)) / dy**2

A_t = np.kron(np.eye(Ny - 2), Ax) + np.kron(Ay, np.eye(Nx - 2))

A_trap1 = np.eye((Nx - 2) * (Ny - 2))- (dt/2) * 0.1 * A_t
A_trap2 = np.eye((Nx - 2) * (Ny - 2)) + (dt/2) * 0.1 * A_t

for k in range(Nt - 1):
  U_ravel = U[1:-1, 1:-1, k].ravel()
  U_ravel = sp.linalg.solve(A_trap1, A_trap2.dot(U_ravel))
  U[1:-1, 1:-1, (k + 1)] = U_ravel.reshape((Nx - 2, Ny - 2))

index_x3 = int((0.5 - 0) / 0.1)
index_y3 = int((0.5 - 0) / 0.1)
index_t3 = Nt - 1
A20 = U[index_x3, index_y3, index_t3]
print("A20 = {}".format(A20))

X, Y = np.meshgrid(x, y)
time_indices = [0, 0.33, 0.67, 1]
fig, axes = plt.subplots(2, 2, figsize=(10, 8), subplot_kw={'projection': '3d'})
fig.suptitle('Surface Plots of Trapezoidal Solution at dt = 0.01', fontsize=16)
for idx, ax in zip(time_indices, axes.flatten()):
    time_index = int(idx * (Nt - 1))
    surf = ax.plot_surface(X, Y, U[:, :, time_index], cmap='viridis', alpha=0.7)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('U')
    ax.set_title(f'Time = {t[time_index]:.2f}')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# u_t = -c * u_x
# u(0, x) = u0(x)
# u(t, 0) = u(t, 1)
# u(t, x) = true_solution

c = 1

def u0(x):
    return np.exp(-50 * (x - 0.5) ** 2)

def true_solution(t, x):
    return u0(np.mod(x - c * t, 1))

x0 = 0
xf = 1
Nx = 101
x = np.linspace(x0, xf, Nx)
dx = x[1] - x[0]
print("Nx = {}".format(Nx))
print("dx = {}".format(dx))

t0 = 0
tf = 1
Nt = 101
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]
print("Nt = {}".format(Nt))
print("dt = {}".format(dt))

plot_rows = 3
plot_cols = 3
num_plots = plot_rows * plot_cols
t_plot = np.linspace(t0, tf, num_plots)

fig = plt.figure()
fig.suptitle("True Solution")
for j, tval in enumerate(t_plot):
    k = round(tval / dt)
    ax = fig.add_subplot(plot_rows, plot_cols, j + 1)
    ax.set_title("t = {:.2f}".format(tval))
    ax.plot(x, true_solution(tval, x))
    ax.set_ylim((-1, 1))
plt.subplots_adjust(hspace=0.5)
plt.show()

# Lax-Friedrichs
A = np.diag(np.ones(Nx - 2), 1) - np.diag(np.ones(Nx - 2), -1)
A[0, -1] = -1
A[-1, 0] = 1
A = (-c / (2 * dx)) * A

B = np.diag(np.ones(Nx - 2), 1) + np.diag(np.ones(Nx - 2), -1)
B[0, -1] = 1
B[-1, 0] = 1
B = 0.5 * B

U = np.zeros((Nx, Nt))
U[:, 0] = u0(x)

for k in range(Nt - 1):
    U[:-1, (k + 1):(k + 2)] = B @ U[:-1, k:(k + 1)] + dt * A @ U[:-1, k:(k + 1)]
U[-1, :] = U[0, :]

fig = plt.figure()
fig.suptitle("Lax-Friedrichs")
for j, tval in enumerate(t_plot):
    k = round(tval / dt)
    ax = fig.add_subplot(plot_rows, plot_cols, j + 1)
    ax.set_title("t = {:.2f}".format(tval))
    ax.plot(x, U[:, k])
    ax.set_ylim((-1, 1))
plt.subplots_adjust(hspace=0.5)
plt.show()

import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

# u_t = -2*u_x
# u(t, 0) = u(t, 1)
# u(0, x) = sin(pi * x)
# u(t, x) = sin(pi * (x - 2*t)) <- That's not right!

# Just to make this code operational, I switched the initial
# condition to
# u(0, x) = sin(2 * pi * x)
# and so the true solution really is
# u(t, x) = sin(2 * pi * (x - 2 * t))

c = 2

Nx = 101
x0 = 0
xN = 1
x = np.linspace(x0, xN, Nx)
dx = x[1] - x[0]

t0 = 0
tf = 4
Nt = 1001
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]
print("dt = {}".format(dt))

A = np.diag(np.ones(Nx - 2), 1) - np.diag(np.ones(Nx - 2), -1)
A[0, -1] = -1
A[-1, 0] = 1
A = (- c / (2 * dx)) * A

U = np.zeros((Nx, Nt))
U[:-1, 0] = np.sin(2 * np.pi * x[:-1])

# Forward Euler
# for k in range(Nt - 1):
#     U[:-1, (k + 1):(k + 2)] = U[:-1, k:(k + 1)] + dt * A @ U[:-1, k:(k + 1)]
# U[-1, :] = U[0, :]

# Backward Euler
for k in range(Nt - 1):
    U[:-1, (k + 1):(k + 2)] = np.linalg.solve(np.eye(Nx - 1) - dt * A, U[:-1, k:(k + 1)])
U[-1, :] = U[0, :]

T, X = np.meshgrid(t, x)

ax = plt.axes(projection='3d')
ax.plot_surface(T, X, U)
plt.title("Solution")
plt.show()

def true_solution(t, x):
    return np.sin(2 * np.pi * (x - c * t)) # <- This was wrong in class

err = U - true_solution(T, X)
ax = plt.axes(projection='3d')
ax.plot_surface(T, X, err)
plt.title("Error")
plt.show()
print("Global Error = {}".format(np.max(np.abs(err))))

vals, _ = np.linalg.eig(A)
print(sorted(dt * vals))

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np
import scipy
import time

# u_xx + u_yy = 0
# u(x, 0) = x^2 - x
# All other boundaries are zero
# u(x, 1) = u(0, y) = u(1, y) = 0

x0 = 0
xN = 1
y0 = 0
yN = 1

N = 501
x = np.linspace(x0, xN, N)
y = np.linspace(y0, yN, N)
dx = x[1] - x[0]
print("N = {}".format(N))
print("dx = {}".format(dx))

# Boundary condition u(x, 0)
def a(x):
    return x ** 2 - x

t0 = time.time()
# Set up system Au = b
N_total = (N - 2) * (N - 2)
print("N_total = {}".format(N_total))
print("Entries in matrix = {}".format(N_total ** 2))
# A = np.zeros((N_total, N_total))
# A = scipy.sparse.dok_array((N_total, N_total))
row_vec = np.zeros(5 * N_total, dtype='int32')
col_vec = np.zeros(5 * N_total, dtype='int32')
data_vec = np.zeros(5 * N_total)
b = np.zeros((N_total, 1))

def point2ind(m, n):
    return (n - 1) * (N - 2) + m - 1

ind = 0
for n in range(1, N-1):
    for m in range(1, N-1):
        k = point2ind(m, n)
        # A[k, k] = -4 / dx ** 2
        row_vec[ind] = k
        col_vec[ind] = k
        data_vec[ind] = -4 / dx ** 2
        ind = ind + 1
        if m > 1:
            # A[k, k - 1] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k - 1
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if n < N - 2:
            # A[k, k + N - 2] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k + N - 2
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if m < N - 2:
            # A[k, k + 1] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k + 1
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if n > 1:
            # A[k, k - (N - 2)] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k - (N - 2)
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        else:
            b[k] = b[k] - a(x[m]) / dx ** 2

A = scipy.sparse.csc_array((data_vec[0:ind], (row_vec[0:ind], col_vec[0:ind])), shape=(N_total, N_total))
t1 = time.time()
print("Time to set up matrix = {}s".format(t1 - t0))

# Solve system
t2 = time.time()
# u = np.linalg.solve(A, b)
# u = scipy.sparse.linalg.spsolve(A, b)
# u, _ = scipy.sparse.linalg.cg(A, b)
# u, _ = scipy.sparse.linalg.bicgstab(A, b)
# u, _ = scipy.sparse.linalg.minres(A, b, tol=1e-10)
u, _ = scipy.sparse.linalg.gmres(A, b)
t3 = time.time()
print("Time to solve = {}s".format(t3 - t2))
print("Total time = {}s".format(t3 - t0))

U_int = u.reshape((N-2, N-2))
U = np.zeros((N, N))
U[1:(N-1), 1:(N-1)] = U_int
U[0, :] = a(x)

# These vectors are just to plot the boundary conditions
zero_vector = np.zeros_like(x)
one_vector = np.ones_like(x)

X, Y = np.meshgrid(x, y)

ax = plt.axes(projection='3d')
# Plot the solution
ax.plot_surface(X, Y, U)
# u(0, y) = 0
ax.plot3D(zero_vector, y, zero_vector, 'r')
# u(x, 1) = 0
ax.plot3D(x, one_vector, zero_vector, 'r')
# u(1, y) = 0
ax.plot3D(one_vector, y, zero_vector, 'r')
# u(x, 0) = a(x)
ax.plot3D(x, zero_vector, a(x), 'r')
plt.show()