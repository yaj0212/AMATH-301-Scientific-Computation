# -*- coding: utf-8 -*-
"""AMATH481-HW3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EseAwfoXvfBxd41emTLdS4kdsWTeFgM_
"""

import numpy as np
import matplotlib.pyplot as plpt
import scipy
from scipy.integrate import solve_ivp

#Problem 1

# theta'' + 0.1 * theta' + sin(theta) = 0
# theta(0) = 0.5
# theta(6) = 0.5
# dt = 0.06

# (a)
dt = 0.06
theta_0 = 0.5
theta_N = 0.5
t0 = 0
tN = 6
t = np.arange(t0, tN + dt / 2, dt)
N = len(t)
# print(N)

def F(y):
    z = np.zeros_like(y)
    z[0] = y[0] - theta_0
    z[-1] = y[-1] - theta_N
    for k in range(1, len(y) - 1):
        z[k] = (1 - 0.05 * dt) * y[k - 1] - 2 * y[k] + (1 + 0.05 * dt) * y[k + 1] + dt ** 2 * np.sin(y[k])
    return z

def jacobian(y):
    J = np.zeros((N, N))
    J[0, 0] = 1
    J[-1, -1] = 1
    for k in range(1, N-1):
        J[k, k - 1] = 1 - 0.05 * dt
        J[k, k] = -2 + dt ** 2 * np.cos(y[k,0])
        J[k, k + 1] = 1 + 0.05 * dt
    return J

y = np.ones((N, 1)) * 0.5
k = 0
max_steps = 500
while np.max(np.abs(F(y))) >= 1e-8 and k < max_steps:
    change_in_y = np.linalg.solve(jacobian(y), F(y))
    y = y - change_in_y
    k = k + 1

y = y.reshape(N)
# print("k = {}".format(k))
te3 = int((N - 1) / 2)
# print(te3)
A1= y[te3]
print(A1)
A2 = np.max(y)
A3 = np.min(y)
print(A2)
print(A3)


# (b)
def theta_guess(t):
  theta_guess = np.zeros((N, 1))
  for i in range(N):
    theta_guess[i] = 0.005 * (t[i] ** 4) - 0.07 * (t[i] ** 3) + 0.66 * (t[i] ** 2) - (2.56 * t[i]) + 0.55
  return theta_guess

y_theta = theta_guess(t)
k = 0
max_steps = 500
while np.max(np.abs(F(y_theta))) >= 1e-8 and k < max_steps:
    change_in_y = np.linalg.solve(jacobian(y_theta), F(y_theta))
    y_theta = y_theta - change_in_y
    k = k + 1
y_theta = y_theta.reshape(N)
# print(y_theta)
A4 = y_theta[te3]
A5 = np.max(y_theta)
A6 = np.min(y_theta)
print(A4)
print(A5)
print(A6)

# Problem 2

# u_xx + u_yy = 0
# u(x, 0) = x^2 - 3x
# u(x, 3) = sin(2*pi*x / 3)
# u(0, y) = sin(pi * y / 3)
# u(3, y) = 3y - y^2

x0 = 0
xN = 3
y0 = 0
yN = 3
dx = 0.05
dy = 0.05
x = np.arange(x0, xN + dx / 2, dx)
y = np.arange(y0, yN + dy / 2, dy)

N1 = len(y)
N2 = len(x)
N_total = N1 * N2

A = np.zeros((N_total,  N_total))
b = np.zeros((N_total, 1))

# Boundary condition and initial condition
def a(x):
    return x ** 2 - 3 * x

def bb(y):
    return 3 * y - y ** 2

def c(x):
    return np.sin(2 * x * np.pi / 3)

def d(y):
    return np.sin(y * np.pi / 3)

def point2ind(m, n):
    return n * N2 + m

for n in range(N1):
  for m in range(N2):
    k = point2ind(m, n)
    if n == 0:
      A[k, k] = 1
      b[k] = a(x[m])
    elif m == 0:
      A[k, k] = 1
      b[k] = d(y[n])
    elif n == N1 - 1:
      A[k, k] = 1
      b[k] = c(x[m])
    elif m == N2 - 1:
      A[k, k] = 1
      b[k] = bb(y[n])
    else:
      A[k, k] = -4
      A[k, k + 1] = 1
      A[k, k - 1] = 1
      A[k, k + N2] = 1
      A[k, k - N2] = 1
      b[k] = 0
u = np.linalg.solve(A, b)
U = u.reshape((N1, N2))
index_x1 = np.where(x == 1)[0]
index_y1 = np.where(y == 1)[0]
index_x2 = np.where(x == 2)[0]
index_y2 = np.where(y == 2)[0]
A7 = U[index_y1, index_x1]
A8 = U[index_y2, index_x2]
print(A7)
print(A8)

#(b)
dx = 0.015
dy = 0.015
x = np.arange(x0, xN + dx / 2, dx)
y = np.arange(y0, yN + dy / 2, dy)

N1 = len(y)
N2 = len(x)
N_total = N1 * N2
A = scipy.sparse.dok_array((N_total,  N_total))
b = np.zeros((N_total, 1))

for n in range(N1):
  for m in range(N2):
    k = point2ind(m, n)
    if n == 0:
      A[k, k] = 1
      b[k] = a(x[m])
    elif m == 0:
      A[k, k] = 1
      b[k] = d(y[n])
    elif n == N1 - 1:
      A[k, k] = 1
      b[k] = c(x[m])
    elif m == N2 - 1:
      A[k, k] = 1
      b[k] = bb(y[n])
    else:
      A[k, k] = -4
      A[k, k + 1] = 1
      A[k, k - 1] = 1
      A[k, k + N2] = 1
      A[k, k - N2] = 1
      b[k] = 0
u = scipy.sparse.linalg.spsolve(A, b)
U = u.reshape((N1, N2))
tolerance = 1e-8
index_x3 = np.where(np.isclose(x, 1.995, atol=tolerance))[0]
index_y3 = np.where(np.isclose(y, 1.995, atol=tolerance))[0]
index_x4 = np.where(x == 1.005)[0]
index_y4 = np.where(y == 1.005)[0]
A9 = U[index_y4, index_x4]
A10 = U[index_y3, index_x3]
print(A9)
print(A10)

# Problem 3

# u_xx + u_yy = -e^(-(x^2 + y^2))
# u(x, 1) = (x^3 - 3) / 3
# u(x, -1) = 0
# u(-1, y) = 0 = u(1, y)

x0 = -1
xN = 1
y0 = -1
yN = 1
dx = 0.1
dy = 0.05
x = np.arange(x0, xN + dx / 2, dx)
y = np.arange(y0, yN + dy / 2, dy)

N = len(y)
M = len(x)
total = N * M
A = np.zeros((total, total))
b = np.zeros((total, 1))

def a_3(x):
  return (x ** 3 - x) / 3

def point2ind(m, n):
    return n * M + m

for n in range(N):
   for m in range(M):
        k = point2ind(m, n)
        if n == N - 1:
            A[k, k] = 1
            b[k] = a_3(x[m])
        elif m == 0 or n == 0 or m == M - 1:
            A[k, k] = 1
            b[k] = 0
        else:
            A[k, k] = (-2 * (dy ** 2) - 2 * (dx ** 2)) / ((dx * dy) ** 2)
            A[k, k + 1] = 1 / (dx ** 2)
            A[k, k - 1] = 1 / (dx ** 2)
            A[k, k + M] = 1 / (dy ** 2)
            A[k, k - M] = 1 / (dy ** 2)
            b[k] = -np.exp(-2 * (x[m] ** 2 + y[n] ** 2))

u = np.linalg.solve(A, b)
U = u.reshape((N, M))
tolerance = 1e-8
index_x2 = np.where(np.isclose(x, -0.5, atol=tolerance))[0]
index_y2 = np.where(np.isclose(y, 0.5, atol=tolerance))[0]
index_x = np.where(np.isclose(x, 0, atol=tolerance))[0]
index_y = np.where(np.isclose(y, 0, atol=tolerance))[0]
A11 = U[index_y, index_x]
A12 = U[index_y2, index_x2]
print(A11)
print(A12)

dx = 0.01
dy = 0.025
x = np.arange(x0, xN + dx / 2, dx)
y = np.arange(y0, yN + dy / 2, dy)

N = len(y)
M = len(x)
total = N * M
A = scipy.sparse.dok_array((total, total))
b = np.zeros((total, 1))


for n in range(N):
    for m in range(M):
        k = point2ind(m, n)
        if n == N - 1:
            A[k, k] = 1
            b[k] = a_3(x[m])
        elif m == 0 or n == 0 or m == M - 1:
            A[k, k] = 1
            b[k] = 0
        else:
            A[k, k] = (-2 * (dy ** 2) - 2 * (dx ** 2)) / ((dx * dy) ** 2)
            A[k, k + 1] = 1 / (dx ** 2)
            A[k, k - 1] = 1 / (dx ** 2)
            A[k, k + M] = 1 / (dy ** 2)
            A[k, k - M] = 1 / (dy ** 2)
            b[k] = -np.exp(-2 * (x[m] ** 2 + y[n] ** 2))

u = scipy.sparse.linalg.spsolve(A, b)
U = u.reshape((N, M))
tolerance = 1e-8
index_x2 = np.where(np.isclose(x, -0.5, atol=tolerance))[0]
index_y2 = np.where(np.isclose(y, 0.5, atol=tolerance))[0]
index_x = np.where(np.isclose(x, 0, atol=tolerance))[0]
index_y = np.where(np.isclose(y, 0, atol=tolerance))[0]
A13 = U[index_y, index_x]
A14 = U[index_y2, index_x2]
print(A13)
print(A14)

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np
import scipy
import time

# u_xx + u_yy = 0
# u(x, 0) = x^2 - x
# All other boundaries are zero
# u(x, 1) = u(0, y) = u(1, y) = 0

x0 = 0
xN = 1
y0 = 0
yN = 1

N = 501
x = np.linspace(x0, xN, N)
y = np.linspace(y0, yN, N)
dx = x[1] - x[0]
print("N = {}".format(N))
print("dx = {}".format(dx))

# Boundary condition u(x, 0)
def a(x):
    return x ** 2 - x

t0 = time.time()
# Set up system Au = b
N_total = (N - 2) * (N - 2)
print("N_total = {}".format(N_total))
print("Entries in matrix = {}".format(N_total ** 2))
# A = np.zeros((N_total, N_total))
# A = scipy.sparse.dok_array((N_total, N_total))
row_vec = np.zeros(5 * N_total, dtype='int32')
col_vec = np.zeros(5 * N_total, dtype='int32')
data_vec = np.zeros(5 * N_total)
b = np.zeros((N_total, 1))

def point2ind(m, n):
    return (n - 1) * (N - 2) + m - 1

ind = 0
for n in range(1, N-1):
    for m in range(1, N-1):
        k = point2ind(m, n)
        # A[k, k] = -4 / dx ** 2
        row_vec[ind] = k
        col_vec[ind] = k
        data_vec[ind] = -4 / dx ** 2
        ind = ind + 1
        if m > 1:
            # A[k, k - 1] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k - 1
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if n < N - 2:
            # A[k, k + N - 2] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k + N - 2
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if m < N - 2:
            # A[k, k + 1] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k + 1
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        if n > 1:
            # A[k, k - (N - 2)] = 1 / dx ** 2
            row_vec[ind] = k
            col_vec[ind] = k - (N - 2)
            data_vec[ind] = 1 / dx ** 2
            ind = ind + 1
        else:
            b[k] = b[k] - a(x[m]) / dx ** 2

A = scipy.sparse.csc_array((data_vec[0:ind], (row_vec[0:ind], col_vec[0:ind])), shape=(N_total, N_total))
t1 = time.time()
print("Time to set up matrix = {}s".format(t1 - t0))

# Solve system
t2 = time.time()
# u = np.linalg.solve(A, b)
# u = scipy.sparse.linalg.spsolve(A, b)
# u, _ = scipy.sparse.linalg.cg(A, b)
# u, _ = scipy.sparse.linalg.bicgstab(A, b)
# u, _ = scipy.sparse.linalg.minres(A, b, tol=1e-10)
u, _ = scipy.sparse.linalg.gmres(A, b)
t3 = time.time()
print("Time to solve = {}s".format(t3 - t2))
print("Total time = {}s".format(t3 - t0))

U_int = u.reshape((N-2, N-2))
U = np.zeros((N, N))
U[1:(N-1), 1:(N-1)] = U_int
U[0, :] = a(x)

# These vectors are just to plot the boundary conditions
zero_vector = np.zeros_like(x)
one_vector = np.ones_like(x)

X, Y = np.meshgrid(x, y)

ax = plt.axes(projection='3d')
# Plot the solution
ax.plot_surface(X, Y, U)
# u(0, y) = 0
ax.plot3D(zero_vector, y, zero_vector, 'r')
# u(x, 1) = 0
ax.plot3D(x, one_vector, zero_vector, 'r')
# u(1, y) = 0
ax.plot3D(one_vector, y, zero_vector, 'r')
# u(x, 0) = a(x)
ax.plot3D(x, zero_vector, a(x), 'r')
plt.show()

import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

# u_t = -2*u_x
# u(t, 0) = u(t, 1)
# u(0, x) = sin(pi * x)
# u(t, x) = sin(pi * (x - 2*t)) <- That's not right!

# Just to make this code operational, I switched the initial
# condition to
# u(0, x) = sin(2 * pi * x)
# and so the true solution really is
# u(t, x) = sin(2 * pi * (x - 2 * t))

c = 2

Nx = 101
x0 = 0
xN = 1
x = np.linspace(x0, xN, Nx)
dx = x[1] - x[0]

t0 = 0
tf = 4
Nt = 1001
t = np.linspace(t0, tf, Nt)
dt = t[1] - t[0]
print("dt = {}".format(dt))

A = np.diag(np.ones(Nx - 2), 1) - np.diag(np.ones(Nx - 2), -1)
print(A)
A[0, -1] = -1
A[-1, 0] = 1
A = (- c / (2 * dx)) * A

U = np.zeros((Nx, Nt))
U[:-1, 0] = np.sin(2 * np.pi * x[:-1])

# Forward Euler
for k in range(Nt - 1):
    U[:-1, (k + 1):(k + 2)] = U[:-1, k:(k + 1)] + dt * A @ U[:-1, k:(k + 1)]
U[-1, :] = U[0, :]

# Backward Euler
# for k in range(Nt - 1):
#    U[:-1, (k + 1):(k + 2)] = np.linalg.solve(np.eye(Nx - 1) - dt * A, U[:-1, k:(k + 1)])
# U[-1, :] = U[0, :]

T, X = np.meshgrid(t, x)

ax = plt.axes(projection='3d')
ax.plot_surface(T, X, U)
plt.title("Solution")
plt.show()

def true_solution(t, x):
    return np.sin(2 * np.pi * (x - c * t)) # <- This was wrong in class

err = U - true_solution(T, X)
ax = plt.axes(projection='3d')
ax.plot_surface(T, X, err)
plt.title("Error")
plt.show()
print("Global Error = {}".format(np.max(np.abs(err))))

vals, _ = np.linalg.eig(A)
print(sorted(dt * vals))