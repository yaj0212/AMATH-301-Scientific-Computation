# -*- coding: utf-8 -*-
"""AMATH481—HW2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QX61Ek-H3M4JmZ5Fih6rQLUijsJaW1KB
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
def bisection(f, a, b, tol):
    x = (a + b) / 2
    while np.abs(b - a) >= tol:
        if np.sign(f(x)) == np.sign(f(a)):
          a=x
        else:
          b=x
        x = (a + b) / 2
    return x

L = 1
x0 = -L
y0 = 0
xf = L
yf = 0

def f(x, y, Lambda):
    return np.array([y[1], - (V(x) + Lambda) * y[0]])

def V(x):
    return -100 * (np.sin(2 * x) + 1)

A = 1
def shoot(Lambda):
    A = 1
    tspan = np.array([x0, xf])
    init_condition = np.array([y0, A])
    sol = solve_ivp(lambda x, y: f(x, y, Lambda), tspan, init_condition)
    return sol.y[0, -1]

Lambda = bisection(shoot, 23, 24, 1e-8)
A1 = Lambda
print(A1)

tspan = np.array([x0, xf])
init_condition = np.array([y0, A])
sol = solve_ivp(lambda x, y: f(x, y, Lambda), tspan, init_condition, t_eval=np.array([-1,0,1]))
x = sol.t
y = sol.y[0,:]
A2 = y[1]
print(A2)

Lamda = bisection(shoot, 24, 78, 1e-8)
A3 = Lamda
print(A3)

tspan = np.array([x0, xf])
init_condition = np.array([y0, A])
sol = solve_ivp(lambda x, y: f(x, y, Lamda), tspan, init_condition, t_eval=np.array([-1,0,1]))
x = sol.t
y = sol.y[0,:]
A4 = y[1]
print(A4)

Lamda = bisection(shoot, 65 , 150, 1e-8)
A5 = Lamda


tspan = np.array([x0, xf])
init_condition = np.array([y0, A])
sol = solve_ivp(lambda x, y: f(x, y, Lamda), tspan, init_condition, t_eval=np.array([-1,0,1]))
x = sol.t
y = sol.y[0,:]
A6 = y[1]

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# x′′ −x=0 with x(0)=1 and x′(0)=0
x0 = 1
t0 = 0
tN = 1
dt = 0.1
dx0 = 0

# trapezoidal
def trapezoidal(dt):
  x_initial = np.array([1, 0])
  t_span = np.arange(0, 1 + dt / 2, dt)
  x = np.ones([2, len(t_span)])
  x[:, 0] = x_initial
  for i in range(len(t_span) - 1):
    x[0, i + 1] = ((4 + dt ** 2) / (4 - dt ** 2)) * x[0, i] + ((4 * dt) / (4 - dt ** 2)) * x[1, i]
    x[1, i + 1] = ((4 + dt ** 2) / (4 - dt ** 2)) * x[1, i] + ((4 * dt) / (4 - dt ** 2)) * x[0, i]
  return x

def f(x, t):
  return np.array

def f_true(t):
  return 1/2 * (np.exp(t) + np.exp(-t))

t = np.arange(t0, tN + dt / 2, dt)
x = np.zeros_like(t)
x[0] = x0
x = trapezoidal(dt)
A7 = x[0, -1]
print(A7)
A8 = abs(x[0, -1] - f_true(t[-1]))
print(A8)

dt = 0.01
t_span = np.arange(0, 1 + dt / 2, dt)
x = trapezoidal(dt)
A9 = x[0, -1]
A10 = abs(x[0, -1] - f_true(t_span[-1]))
print(A9)
print(A10)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
# x′′ +x=0 with x(0)=1 and x′(0)=0
x0 = 1
t0 = 0
tN = 1
dt = 0.1
dx0 = 0

def f(t, x):
    return np.array([x[1], -x[0]])

def f_true(t):
    return np.cos(t)

def midpoint(dt):
    x_ini = np.array([1, 0])
    t_span = np.arange(0, 1 + dt / 2, dt)
    x = np.zeros([2, len(t_span)])
    x[:, 0] = x_ini
    x[:, 1] = x[:, 0] + dt * f(t_span[0], x[:, 0])
    for i in range(1, len(t_span) - 1):
        x[:, i + 1] = x[:, i - 1] + 2 * dt * f(t_span[i], x[:, i])
    return x

dt = 0.1
t_span = np.arange(0, 1 + dt / 2, dt)
x = midpoint(dt)
A11 = x[0, -1]
A12 = abs(x[0, -1] - f_true(t_span[-1]))
print(A11)
print(A12)

dt = 0.01
t_span = np.arange(0, 1 + dt / 2, dt)
x = midpoint(dt)
A13 = x[0, -1]
A14 = abs(x[0, -1] - f_true(t_span[-1]))
print(A13)
print(A14)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

x0 = -0.5
y0 = -0.5
xf = 0.5
yf = 0.5
dt = 0.1
N = 11
x = np.linspace(x0, xf, N)
dx = x[1] - x[0]
a = 1

def cheby(a):
    A = np.zeros((N, N))
    b = np.zeros((N, 1))
    A[0, 0] = 1
    b[0] = y0
    A[-1, -1] = 1
    b[-1] = yf
    for i in range(1, N - 1):
        A[i, i - 1] = ((1 - x[i] ** 2) / dx ** 2 + x[i] / (2 * dx))
        A[i, i] = -2 * (1 - x[i] ** 2) / dx ** 2 + a ** 2
        A[i, i + 1] = ((1 - x[i] ** 2) / dx ** 2 - x[i] / (2 * dx))
    y = np.linalg.solve(A, b).reshape(N)
    return y, x

def f_true(x):
  return x

y, x = cheby(a)
A15 = y[5]
A16 = np.max(np.abs(f_true(x) - y))
print(A15)
print(A16)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

x0 = -0.5
y0 = 0.5
xf = 0.5
yf = 0.5
dt = 0.1
N = 11
x = np.linspace(x0, xf, N)
dx = x[1] - x[0]
a = 2

def cheby(a):
    A = np.zeros((N, N))
    b = np.zeros((N, 1))
    A[0, 0] = 1
    b[0] = y0
    A[-1, -1] = 1
    b[-1] = yf
    for i in range(1, N - 1):
        A[i, i - 1] = ((1 - x[i] ** 2) / dx ** 2 + x[i] / (2 * dx))
        A[i, i] = -2 * (1 - x[i] ** 2) / dx ** 2 + a ** 2
        A[i, i + 1] = ((1 - x[i] ** 2) / dx ** 2 - x[i] / (2 * dx))
    y = np.linalg.solve(A, b).reshape(N)
    return y, x

def f_true(x):
  return 1 - 2 * (x ** 2)

y, x = cheby(a)
A17 = y[5]
A18 = np.max(np.abs(f_true(x) - y))
print(A17)
print(A18)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

x0 = -0.5
y0 = - 1/3
xf = 0.5
yf = 1 / 3
dt = 0.1
N = 11
x = np.linspace(x0, xf, N)
dx = x[1] - x[0]
a = 3

def cheby(a):
    A = np.zeros((N, N))
    b = np.zeros((N, 1))
    A[0, 0] = 1
    b[0] = y0
    A[-1, -1] = 1
    b[-1] = yf
    for i in range(1, N - 1):
        A[i, i - 1] = ((1 - x[i] ** 2) / dx ** 2 + x[i] / (2 * dx))
        A[i, i] = -2 * (1 - x[i] ** 2) / dx ** 2 + a ** 2
        A[i, i + 1] = ((1 - x[i] ** 2) / dx ** 2 - x[i] / (2 * dx))
    y = np.linalg.solve(A, b).reshape(N)
    return y, x

def f_true(x):
  return x - (4 / 3) * x ** 3

y, x = cheby(a)
A19 = y[5]
A20 = np.max(np.abs(f_true(x) - y))
print(A19)
print(A20)

import numpy as np
dx = 0.005
A = (-200*np.diag(-2 * np.ones(9)) + 100*np.diag(np.ones(8), 1) +100*np.diag(np.ones(8), -1))
vals, _ = np.linalg.eig(A)
print("Eigenvalues of A = {}".format(sorted(vals)))
print("dt * Lambda = {}".format(sorted(dx * vals)))